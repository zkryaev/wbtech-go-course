package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

/*

	Применимость:
		1. Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
		2. Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
		3. Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
		4. Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.

	Плюсы и минусы:
		+ Горячая замена алгоритмов на лету.
		+ Изолирует код и данные алгоритмов от остальных классов.
		+ Уход от наследования к делегированию.
		+ Реализует _принцип открытости/закрытости_.
		- Усложняет программу за счёт дополнительных классов.
		- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

*/

func main() {
	s := &SomeStrategy{}
	context := &Context{}
	context.SetStrategy(s)
	context.DoSmtg()
}

type Strategy interface {
	execute(int)
}

type SomeStrategy struct {
}

func (s SomeStrategy) execute(data int) {
	fmt.Println(data)
}

type Context struct {
	strategy Strategy
}

func (c *Context) SetStrategy(s Strategy) {
	c.strategy = s
}

func (c *Context) DoSmtg() {
	c.strategy.execute(12)
}
